# Safe Unlink Exploit

## Summary

- Header leak with corresponding address
- Scudo library base leak
- Three consecutive frees on the same address
  - Control over the `0x10` bytes in front of the address before the first two free's
  - Control over the `0x40` bytes in front of the address before the third free

Result:
Next allocation will be a chunk in the perclass structure itself (thread-local free list), allowing control of future allocations


## Requirements

The safe unlink exploit has a certain number of requirements that the target binary needs to fulfill.

First of all we need a header leak of any chunk from the heap as well as it's address, in order to bruteforce the cookie. Afterwards we can forge any header checksum from the cookie we calculated from this leak.

Second we need a free for which we can control a certain number of bytes before the free, more specifically we need to control `0x40` bytes in front of the address of the free. This is the size of the secondary header plus the size of the padded primary header.

Third we need two interesting places in memory (at addresses `add1` and `add2` resepectively) that have the address of the free address from the previous step stored. We will store `add2` at `add1+0x8` and `add1` at `add2`. Therefore `add1` and `add2` should be in some interesting location allowing elevation of our access.  
The easiest way to get this is by having two more free's of the chunk in the previous step and being able to control the `0x10` bytes in front of the address to modify the header. With this method we however also need a leak of the scudo lib base, in order to get the location of the thread-local free list (PerClass list).

## Explanation

As with most scudo exploits, the first step is to get the cookie, which can be done from any single header leak, as explained in the dedicated section.

Then we need to have two locations in memory that point to the chunk we will tamper with in the next section. The way we achieve this is by having two frees on that same chunk, leaving it's address twice in the perclass structure next to each other. The perclass structure constitutes the first level, thread specific free list of chunks. It is handled as a simple array of chunk addresses, and therefore freeing the same chunk twice leaves two pointers to that chunk right next to each other in the perclass structure. This setup is especially interesting since getting the allocation of a chunk in the perclass structure could allow us to control all following allocations and to allocate chunks at arbitrary addresses. The only obstacle is that we need to modify the chunk header before the second free to mark the chunk as allocated again.

Once we have setup the two addresses in the perclass array, we need to know it's address still. To calculate the address of the perclass array(s) we need to have a leak of some scudo address, like the base address where scudo is loaded or the address of the malloc function. We can calculate the offset needed from there based on the scudo version, and then advance by `0x100` times the value of the class id where we free'd the chunks. Then we just need to guess the number of chunks present in the perclass structure of that class id.

Finally we need to prepare the header of the final free that will trigger the safe unlink. For that we need to configure a fake secondary header in front of the primary header, as well as modifying the latter to set it's class id to 0. We set the prev (`chunk_addr - 0x40`) to the first of our locations - `0x8` and the next (`chunk_addr - 0x38`) to the second of our locations. With the perclass setup, we can set both of them to the address where the first of the two addresses is stored.
Next follow the CommitBase, CommitSize and MapBase, MapSize. We can set them to the values we want, we can set them to whatever since we don't actually use them. They have a size of `0x8` bytes each.
Finally we just need to set the primary header with the class id set to 0 and the checksum recalculated.

When the free of that chunk then happens, it is handed to the secondary allocator since we set the class id to 0. The secondary allocator tries to remove the chunk from the linked list of in use chunks, even when our fake chunk never was in it. So it tries to set the Next->Prev pointer to Prev and the Prev->Next pointer to Next, which leads it to write the addresses of our locations in the perclass structure to those same addresses, which will allow us to allocate a chunk in the perclass structure itself.


```
################
#              #
#   PerClass   #
#              #
#  ##########  #
#              #
#  Scudo base  #
#              #
#  ##########  #
#              #
#    malloc    #
#              #
################
                                 
                                 
### PerClass ###
#              #
#     Count    #
#              #
#  ##########  #
#              #
#   MaxCount   #
#              #
#  ##########  #
#              #
#   ChunkPtr   #
#              #
#  ##########  #
#              #
#      ...     #
#              #
#  ##########  #
#              #
# header_addr  # <- add1
#              #
#  ##########  #
#              #
# header_addr  # <- add2
#              #
################


###################
#                 #
#     add1+0x8    # <- header_addr
#                 #
#  #############  #
#                 #
#       add1      #
#                 #
#  #############  #
#                 #
#    CommitBase   #
#                 #
#  #############  #
#                 #
#    CommitSize   #
#                 #
#  #############  #
#                 #
#     MapBase     #
#                 #
#  #############  #
#                 #
#     MapSize     #
#                 #
#  #############  #
#                 #
#  PrimaryHeader  #
#                 #
#  #############  #
#                 #
#   Chunk Data    # <- chunk_addr
#                 #
###################
```









# Forge Secondary Exploit

## Summary

- Header leak with corresponding address
- At least one secondary chunk allocated
- Free on any address where we control `0x40` bytes in front
- Allocation of secondary chunk of known (approximate) size

Result:
We can choose an arbitrary location for the secondary chunk allocated

## Requirements

The forge secondary exploit has a certain number of requirements that the target binary needs to fulfill.

First of all we need a header leak of any chunk from the heap as well as it's address, in order to bruteforce the cookie. Afterwards we can forge any header checksum from the cookie we calculated from this leak.

Second we need a free for which we can control a certain number of bytes before the free, more specifically we need to control `0x40` bytes in front of the address of the free. This is the size of the secondary header plus the size of the padded primary header.

Third we need there to be at least one secondary chunk allocated before the free, and we need there to be another secondary allocation afterwards, of which we know the approximate size. This is the allocation where we will get our arbitrary access.

## Explanation
